import { GoogleGenAI } from "@google/genai";

// This will be replaced by Vite during build with the actual key string
const ENV_API_KEY = process.env.API_KEY as string;

export const extractCsvFromPdf = async (base64Pdf: string, userApiKey?: string): Promise<string> => {
  // prioritize user key, then env key
  const effectiveKey = userApiKey || (ENV_API_KEY !== 'MISSING_KEY' ? ENV_API_KEY : '');

  // DEMO MODE: If no API key is present, simulate the experience
  if (!effectiveKey) {
    console.log("No API Key detected. Running in DEMO MODE.");
    
    // Simulate network latency / "thinking" time
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Return realistic sample data
    return `Date,Transaction ID,Description,Category,Amount,Status
2024-03-01,TRX-1001,Global Tech Solutions - Web Dev,Income,"5,000.00",Completed
2024-03-03,TRX-1002,Amazon AWS Web Services,Software,"-245.50",Posted
2024-03-05,TRX-1003,Staples Office Supply,Operations,"-89.99",Posted
2024-03-08,TRX-1004,Client Payment - Invoice #4022,Income,"1,250.00",Completed
2024-03-12,TRX-1005,Uber Trip - Client Meeting,Travel,"-24.50",Pending
2024-03-15,TRX-1006,Adobe Creative Cloud,Software,"-54.99",Posted
2024-03-20,TRX-1007,Coffee Shop Meeting,Meals,"-15.75",Posted`;
  }

  try {
    const ai = new GoogleGenAI({ apiKey: effectiveKey });

    // Using gemini-3-pro-preview as requested for complex reasoning
    // High thinking budget for thorough analysis of messy PDFs
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-preview',
      contents: {
        parts: [
          {
            inlineData: {
              mimeType: 'application/pdf',
              data: base64Pdf
            }
          },
          {
            text: `You are a PDF-to-Spreadsheet Extractor AI. Your job is to read the entire PDF I upload and convert all of its content into a clean, well-structured spreadsheet table.

RULES:
1. Extract ALL tables, rows, columns, and text-based data.
2. Reconstruct tables even if they are messy, tilted, scanned, or poorly formatted.
3. Remove duplicates, blank rows, repeated headers, watermarks, or irrelevant text.
4. Detect column headers automatically and standardize them.
5. Align all data into a clean row-and-column format suitable for Excel or Google Sheets.
6. If the PDF has multiple tables, combine them into separate labeled sections or merge if they share the same structure.
7. Output MUST be in pure CSV format â€” no commentary, no explanations, no markdown, no code blocks.
8. Only return the CSV content that can be exported directly into a spreadsheet.

If the PDF contains paragraphs, summarize into proper columns. If it contains forms, convert fields into columns. Normalize invoice line items.

Output ONLY raw CSV data.`
          }
        ]
      },
      config: {
        thinkingConfig: {
            thinkingBudget: 32768 // Max budget for gemini-3-pro-preview
        },
      }
    });

    const text = response.text;
    if (!text) {
      throw new Error("No content generated by the model.");
    }

    let cleanedText = text;
    // Improved regex to capture content inside code blocks, handling optional language identifier
    // Matches ```csv ... ```, ``` ... ```, etc.
    const codeBlockMatch = text.match(/```(?:csv|txt)?\s*([\s\S]*?)\s*```/i);
    if (codeBlockMatch) {
      cleanedText = codeBlockMatch[1];
    } else {
        // Fallback: cleanup if no code blocks but still has potential markdown artifacts
        // Remove leading/trailing backticks if they exist
        cleanedText = text.replace(/^```(?:csv)?/i, '').replace(/```$/i, '');
    }
    
    return cleanedText.trim();

  } catch (error: any) {
    console.error("Gemini API Error:", error);
    
    // If we hit a permission denied or quota error, throw it so the UI can show the specific error
    // We only fallback to demo mode in the explicit absence of a key, not on error.
    throw new Error(error.message || "Failed to process PDF");
  }
};

export const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const result = reader.result as string;
      // Remove data URL prefix (e.g., "data:application/pdf;base64,")
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = error => reject(error);
  });
};